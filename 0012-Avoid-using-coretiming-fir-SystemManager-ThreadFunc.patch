From 0bcb4b34ec3d1fcf8dc66c2bd61808d2f843169f Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Wed, 15 Mar 2023 15:56:38 +0000
Subject: [PATCH 12/13] Avoid using coretiming fir SystemManager ThreadFunc

---
 renderer/system_manager.cpp | 22 ++++++----------------
 renderer/system_manager.h   |  8 +-------
 2 files changed, 7 insertions(+), 23 deletions(-)

diff --git a/renderer/system_manager.cpp b/renderer/system_manager.cpp
index ce631f8..a6044a8 100644
--- a/renderer/system_manager.cpp
+++ b/renderer/system_manager.cpp
@@ -18,11 +18,7 @@ namespace AudioCore::AudioRenderer {
 constexpr std::chrono::nanoseconds RENDER_TIME{5'000'000UL};
 
 SystemManager::SystemManager(Core::System& core_)
-    : core{core_}, adsp{core.AudioCore().GetADSP()}, mailbox{adsp.GetRenderMailbox()},
-      thread_event{Core::Timing::CreateEvent(
-          "AudioRendererSystemManager", [this](std::uintptr_t, s64 time, std::chrono::nanoseconds) {
-              return ThreadFunc2(time);
-          })} {}
+    : core{core_}, adsp{core.AudioCore().GetADSP()}, mailbox{adsp.GetRenderMailbox()} {}
 
 SystemManager::~SystemManager() {
     Stop();
@@ -33,8 +29,6 @@ bool SystemManager::InitializeUnsafe() {
         if (adsp.Start()) {
             active = true;
             thread = std::jthread([this](std::stop_token stop_token) { ThreadFunc(); });
-            core.CoreTiming().ScheduleLoopingEvent(std::chrono::nanoseconds(0), RENDER_TIME,
-                                                   thread_event);
         }
     }
 
@@ -45,7 +39,6 @@ void SystemManager::Stop() {
     if (!active) {
         return;
     }
-    core.CoreTiming().UnscheduleEvent(thread_event, {});
     active = false;
     update.store(true);
     update.notify_all();
@@ -98,6 +91,9 @@ void SystemManager::ThreadFunc() {
     MicroProfileOnThreadCreate(name);
     Common::SetCurrentThreadName(name);
     Common::SetCurrentThreadPriority(Common::ThreadPriority::High);
+
+    std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds> next_render_time = std::chrono::system_clock::now();
+
     while (active) {
         {
             std::scoped_lock l{mutex1};
@@ -112,15 +108,9 @@ void SystemManager::ThreadFunc() {
         adsp.Signal();
         adsp.Wait();
 
-        update.wait(false);
-        update.store(false);
+        next_render_time += RENDER_TIME;
+        std::this_thread::sleep_until(next_render_time);
     }
 }
 
-std::optional<std::chrono::nanoseconds> SystemManager::ThreadFunc2(s64 time) {
-    update.store(true);
-    update.notify_all();
-    return std::nullopt;
-}
-
 } // namespace AudioCore::AudioRenderer
diff --git a/renderer/system_manager.h b/renderer/system_manager.h
index 81457a3..7d9478f 100644
--- a/renderer/system_manager.h
+++ b/renderer/system_manager.h
@@ -3,6 +3,7 @@
 
 #pragma once
 
+#include <chrono>
 #include <list>
 #include <memory>
 #include <mutex>
@@ -68,11 +69,6 @@ private:
      */
     void ThreadFunc();
 
-    /**
-     * Signalling core timing thread to run ThreadFunc.
-     */
-    std::optional<std::chrono::nanoseconds> ThreadFunc2(s64 time);
-
     enum class StreamState {
         Filling,
         Steady,
@@ -95,8 +91,6 @@ private:
     ADSP::ADSP& adsp;
     /// AudioRenderer mailbox for communication
     ADSP::AudioRenderer_Mailbox* mailbox{};
-    /// Core timing event to signal main thread
-    std::shared_ptr<Core::Timing::EventType> thread_event;
     /// Atomic for main thread to wait on
     std::atomic<bool> update{};
 };
-- 
2.39.0

