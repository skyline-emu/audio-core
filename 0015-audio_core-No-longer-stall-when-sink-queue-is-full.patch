From e73eb524c47fbc48125916aaa7e03c7f626ac09d Mon Sep 17 00:00:00 2001
From: Billy Laws <blaws05@gmail.com>
Date: Sun, 26 Mar 2023 20:21:04 +0100
Subject: [PATCH 4/4] audio_core: No longer stall when sink queue is full

Now the audout and audren update rates are tied to the sink status stalling is no longer necessary.
---
 sink/cubeb_sink.cpp  |  4 ---
 sink/sdl2_sink.cpp   |  2 --
 sink/sink_stream.cpp | 43 -----------------------------
 sink/sink_stream.h   | 16 +----------
 4 files changed, 1 insertion(+), 64 deletions(-)

diff --git a/sink/cubeb_sink.cpp b/sink/cubeb_sink.cpp
index 9133f5388..9a0801888 100644
--- a/sink/cubeb_sink.cpp
+++ b/sink/cubeb_sink.cpp
@@ -101,8 +101,6 @@ public:
     ~CubebSinkStream() override {
         LOG_DEBUG(Service_Audio, "Destructing cubeb stream {}", name);
 
-        Unstall();
-
         if (!ctx) {
             return;
         }
@@ -143,8 +141,6 @@ public:
      * Stop the sink stream.
      */
     void Stop() override {
-        Unstall();
-
         if (!ctx || paused) {
             return;
         }
diff --git a/sink/sdl2_sink.cpp b/sink/sdl2_sink.cpp
index c138dc628..ee1a0652f 100644
--- a/sink/sdl2_sink.cpp
+++ b/sink/sdl2_sink.cpp
@@ -88,7 +88,6 @@ public:
      * Finalize the sink stream.
      */
     void Finalize() override {
-        Unstall();
         if (device == 0) {
             return;
         }
@@ -116,7 +115,6 @@ public:
      * Stop the sink stream.
      */
     void Stop() override {
-        Unstall();
         if (device == 0 || paused) {
             return;
         }
diff --git a/sink/sink_stream.cpp b/sink/sink_stream.cpp
index 854da8752..f58e9a715 100644
--- a/sink/sink_stream.cpp
+++ b/sink/sink_stream.cpp
@@ -151,10 +151,6 @@ void SinkStream::ProcessAudioIn(std::span<const s16> input_buffer, std::size_t n
         return;
     }
 
-    if (queued_buffers > max_queue_size) {
-        Stall();
-    }
-
     while (frames_written < num_frames) {
         // If the playing buffer has been consumed or has no frames, we need a new one
         if (playing_buffer.consumed || playing_buffer.frames == 0) {
@@ -189,10 +185,6 @@ void SinkStream::ProcessAudioIn(std::span<const s16> input_buffer, std::size_t n
     }
 
     std::memcpy(&last_frame[0], &input_buffer[(frames_written - 1) * frame_size], frame_size_bytes);
-
-    if (queued_buffers <= max_queue_size) {
-        Unstall();
-    }
 }
 
 void SinkStream::ProcessAudioOutAndRender(std::span<s16> output_buffer, std::size_t num_frames) {
@@ -216,20 +208,6 @@ void SinkStream::ProcessAudioOutAndRender(std::span<s16> output_buffer, std::siz
         return;
     }
 
-    // Due to many frames being queued up with nvdec (5 frames or so?), a lot of buffers also get
-    // queued up (30+) but not all at once, which causes constant stalling here, so just let the
-    // video play out without attempting to stall.
-    // Can hopefully remove this later with a more complete NVDEC implementation.
-    const auto nvdec_active{system.AudioCore().IsNVDECActive()};
-
-    // Core timing cannot be paused in single-core mode, so Stall ends up being called over and over
-    // and never recovers to a normal state, so just skip attempting to sync things on single-core.
-    if (system.IsMulticore() && !nvdec_active && queued_buffers > max_queue_size) {
-        Stall();
-    } else if (system.IsMulticore() && queued_buffers <= max_queue_size) {
-        Unstall();
-    }
-
     while (frames_written < num_frames) {
         // If the playing buffer has been consumed or has no frames, we need a new one
         if (playing_buffer.consumed || playing_buffer.frames == 0) {
@@ -281,27 +259,6 @@ void SinkStream::ProcessAudioOutAndRender(std::span<s16> output_buffer, std::siz
         min_played_sample_count = max_played_sample_count;
         max_played_sample_count += actual_frames_written;
     }
-
-    if (system.IsMulticore() && queued_buffers <= max_queue_size) {
-        Unstall();
-    }
-}
-
-void SinkStream::Stall() {
-    std::scoped_lock lk{stall_guard};
-    if (stalled_lock) {
-        return;
-    }
-    stalled_lock = system.StallApplication();
-}
-
-void SinkStream::Unstall() {
-    std::scoped_lock lk{stall_guard};
-    if (!stalled_lock) {
-        return;
-    }
-    system.UnstallApplication();
-    stalled_lock.unlock();
 }
 
 u64 SinkStream::GetExpectedPlayedSampleCount() {
diff --git a/sink/sink_stream.h b/sink/sink_stream.h
index 9806e6d98..23e289c7b 100644
--- a/sink/sink_stream.h
+++ b/sink/sink_stream.h
@@ -55,9 +55,7 @@ struct SinkBuffer {
 class SinkStream {
 public:
     explicit SinkStream(Core::System& system_, StreamType type_) : system{system_}, type{type_} {}
-    virtual ~SinkStream() {
-        Unstall();
-    }
+    virtual ~SinkStream() {}
 
     /**
      * Finalize the sink stream.
@@ -202,16 +200,6 @@ public:
      */
     void ProcessAudioOutAndRender(std::span<s16> output_buffer, std::size_t num_frames);
 
-    /**
-     * Stall core processes if the audio thread falls too far behind.
-     */
-    void Stall();
-
-    /**
-     * Unstall core processes.
-     */
-    void Unstall();
-
     /**
      * Get the total number of samples expected to have been played by this stream.
      *
@@ -266,8 +254,6 @@ private:
     /// Signalled when ring buffer entries are consumed
     std::condition_variable release_cv;
     std::mutex release_mutex;
-    std::mutex stall_guard;
-    std::unique_lock<std::mutex> stalled_lock;
 };
 
 using SinkStreamPtr = std::unique_ptr<SinkStream>;
-- 
2.39.0

